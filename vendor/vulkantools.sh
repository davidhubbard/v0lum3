#!/bin/bash
#
# This script will build and install VulkanTools, which adds:
#   VK_LAYER_LUNARG_vktrace: record and replay your app's vulkan calls.
#           https://github.com/LunarG/VulkanTools/tree/master/vktrace
#   VK_LAYER_LUNARG_screenshot
#
# (There are also some example layers, see
# https://github.com/LunarG/VulkanTools/tree/master/layersvt)
#
# VulkanTools duplicates some of Vulkan-LoaderAndValidationLayers, but this
# script only installs the unique parts into this directory (which, by you
# exporting PKG_CONFIG_PATH, and by patching VulkanSamples to look in this dir,
# should "just work". Even vkreplay and vktraceviewer run without hacking
# your LD_LIBRARY_PATH.)

set -e

cd $( dirname "$0" )

git clone https://github.com/LunarG/VulkanTools
LUNARGLASS_REVISION=$(cat VulkanTools/LunarGLASS_revision)
PREFIX="${PWD}"

if [ -d LunarGLASS ]; then
  echo "Directory LunarGLASS already exists. Skipping..."
else
  git clone https://github.com/LunarG/LunarGLASS

  (
    cd LunarGLASS
    mkdir -p Core/LLVM
    (
      cd Core/LLVM
      wget http://llvm.org/releases/3.4/llvm-3.4.src.tar.gz
      tar --gzip -xf llvm-3.4.src.tar.gz
      git checkout -f .  # put back the LunarGLASS versions of some LLVM files
      git checkout $LUNARGLASS_REVISION
    )
  )
  cp -R VulkanTools/LunarGLASS/* LunarGLASS

  (
    cd LunarGLASS/Core/LLVM/llvm-3.4
    mkdir -p build
    cd build
    ../configure --enable-terminfo=no --enable-curses=no
    REQUIRES_RTTI=1 make -j $(nproc)
    make install DESTDIR="${PWD}"/install
  )

  (
    cd LunarGLASS
    cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Release "-DGLSLANGLIBS=${PREFIX}/lib" "-DCMAKE_INSTALL_PREFIX=${PREFIX}"
    cd build
    make -j $(nproc) install
  )
fi

(
  cd VulkanTools
  sed -i -e 's,component(LUNARGLASS_PREFIX external/LunarGLASS ABSOLUTE,component(LUNARGLASS_PREFIX ../LunarGLASS ABSOLUTE,' CMakeLists.txt


  #
  # https://github.com/LunarG/VulkanTools/pull/77
  #
  patch -p1 <<EOF
diff --git a/vk-vtgenerate.py b/vk-vtgenerate.py
index 0abdcc9..8b35d77 100755
--- a/vk-vtgenerate.py
+++ b/vk-vtgenerate.py
@@ -31,6 +31,7 @@ class Subcommand(object):
         self.argv = argv
         self.headers = vulkan.headers
         self.protos = vulkan.protos
+        self.extensions = vulkan.extensions
 
     def run(self):
         print(self.generate())
@@ -54,7 +55,7 @@ class Subcommand(object):
         return "\\n\\n".join(contents)
 
     def generate_copyright(self):
-        return """/* THIS FILE IS GENERATED.  DO NOT EDIT. */
+        return """/* THIS FILE IS GENERATED BY vk-vtgenerate.py.  DO NOT EDIT. */
 
 /*
  *
@@ -150,17 +151,22 @@ class IcdGetProcAddrSubcommand(IcdDummyEntrypointsSubcommand):
                        'GetDisplayPlaneSupportedDisplaysKHR', 'GetDisplayModePropertiesKHR',
                        'CreateDisplayModeKHR', 'GetDisplayPlaneCapabilitiesKHR', 'CreateDisplayPlaneSurfaceKHR']
 
-        for proto in self.protos:
-            if proto.name in exclusions:
-                continue
-            lookups.append("if (!strcmp(%s, \\"%s\\"))" %
-                    (gpa_pname, proto.name))
-            if proto.name != "GetInstanceProcAddr":
-                lookups.append("    return (%s) %s%s;" %
-                    (gpa_proto.ret, self.prefix, proto.name))
-            else:
-                lookups.append("    return (%s) %s%s;" %
-                    (gpa_proto.ret, self.prefix, "_icdGetInstanceProcAddr"))
+        for ext in self.extensions:
+            if ext.ifdef:
+                lookups.append("#ifdef %s" % ext.ifdef)
+            for proto in ext.protos:
+                if proto.name in exclusions:
+                    continue
+                lookups.append("if (!strcmp(%s, \\"%s\\"))" %
+                        (gpa_pname, proto.name))
+                if proto.name != "GetInstanceProcAddr":
+                    lookups.append("    return (%s) %s%s;" %
+                        (gpa_proto.ret, self.prefix, proto.name))
+                else:
+                    lookups.append("    return (%s) %s%s;" %
+                        (gpa_proto.ret, self.prefix, "_icdGetInstanceProcAddr"))
+            if ext.ifdef:
+                lookups.append("#endif /* %s */" % ext.ifdef)
 
         body = []
         body.append("%s %s" % (self.qual, gpa_instance_decl))
@@ -203,7 +209,7 @@ def main():
     }
 
     if len(sys.argv) < 3 or sys.argv[1] not in wsi or sys.argv[2] not in subcommands:
-        print("Usage: %s <subcommand> [options]" % sys.argv[0])
+        print("Usage: %s <wsi> <subcommand> [options]" % sys.argv[0])
         print
         print("Available sucommands are: %s" % " ".join(subcommands))
         exit(1)
diff --git a/vktrace/src/vktrace_common/vktrace_multiplatform.h b/vktrace/src/vktrace_common/vktrace_multiplatform.h
index 5fba297..02ad01f 100644
--- a/vktrace/src/vktrace_common/vktrace_multiplatform.h
+++ b/vktrace/src/vktrace_common/vktrace_multiplatform.h
@@ -36,7 +36,7 @@ extern "C" {
 // Unfortunately, some of these are duplicated from vulkan.h
 // and platform-specific header files. Haven't figured out how
 // to avoid this.
-#if defined(WIN32)
+#if !defined(VK_USE_PLATFORM_XCB_KHR)
 typedef VkFlags VkXcbSurfaceCreateFlagsKHR;
 typedef struct xcb_connection_t xcb_connection_t;
 typedef uint32_t xcb_window_t;
@@ -48,6 +48,16 @@ typedef struct VkXcbSurfaceCreateInfoKHR {
     xcb_connection_t*             connection;
     xcb_window_t                  window;
 } VkXcbSurfaceCreateInfoKHR;
+typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
+typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);
+typedef struct {
+    VkIcdSurfaceBase base;
+    xcb_connection_t *connection;
+    xcb_window_t window;
+} VkIcdSurfaceXcb;
+#endif
+
+#if !defined(VK_USE_PLATFORM_XLIB_KHR)
 typedef VkFlags VkXlibSurfaceCreateFlagsKHR;
 struct _XDisplay;
 typedef struct _XDisplay Display;
@@ -62,21 +72,13 @@ typedef struct VkXlibSurfaceCreateInfoKHR {
     Display*                       dpy;
     Window                         window;
 } VkXlibSurfaceCreateInfoKHR;
-typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
-typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);
 typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
 typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);
 typedef struct {
     VkIcdSurfaceBase base;
-    xcb_connection_t *connection;
-    xcb_window_t window;
-} VkIcdSurfaceXcb;
-typedef struct {
-    VkIcdSurfaceBase base;
     Display *dpy;
     Window window;
 } VkIcdSurfaceXlib;
-
 #endif
 
 #if defined(PLATFORM_LINUX)
diff --git a/vktrace/src/vktrace_extensions/vktracevulkan/vkreplay/vkreplay_vkreplay.cpp b/vktrace/src/vktrace_extensions/vktracevulkan/vkreplay/vkreplay_vkreplay.cpp
index 1b2b52f..458f9b0 100644
--- a/vktrace/src/vktrace_extensions/vktracevulkan/vkreplay/vkreplay_vkreplay.cpp
+++ b/vktrace/src/vktrace_extensions/vktracevulkan/vkreplay/vkreplay_vkreplay.cpp
@@ -3014,7 +3014,7 @@ VkResult vkReplay::manually_replay_vkCreateXlibSurfaceKHR(packet_vkCreateXlibSur
         return VK_ERROR_VALIDATION_FAILED_EXT;
     }
 
-#if defined PLATFORM_LINUX
+#if defined PLATFORM_LINUX && defined VK_USE_PLATFORM_XLIB_KHR
     VkIcdSurfaceXlib *pSurf = (VkIcdSurfaceXlib *) m_display->get_surface();
     VkXlibSurfaceCreateInfoKHR createInfo;
     createInfo.sType = pPacket->pCreateInfo->sType;
@@ -3023,6 +3023,17 @@ VkResult vkReplay::manually_replay_vkCreateXlibSurfaceKHR(packet_vkCreateXlibSur
     createInfo.dpy = pSurf->dpy;
     createInfo.window = pSurf->window;
     replayResult = m_vkFuncs.real_vkCreateXlibSurfaceKHR(remappedinstance, &createInfo, pPacket->pAllocator, &local_pSurface);
+#elif defined PLATFORM_LINUX && defined VK_USE_PLATFORM_XCB_KHR
+    VkIcdSurfaceXcb *pSurf = (VkIcdSurfaceXcb *) m_display->get_surface();
+    VkXcbSurfaceCreateInfoKHR createInfo;
+    createInfo.sType = pPacket->pCreateInfo->sType;
+    createInfo.pNext = pPacket->pCreateInfo->pNext;
+    createInfo.flags = pPacket->pCreateInfo->flags;
+    createInfo.connection = pSurf->connection;
+    createInfo.window = pSurf->window;
+    replayResult = m_vkFuncs.real_vkCreateXcbSurfaceKHR(remappedinstance, &createInfo, pPacket->pAllocator, &local_pSurface);
+#elif defined PLATFORM_LINUX
+#error manually_replay_vkCreateXlibSurfaceKHR on PLATFORM_LINUX requires one of VK_USE_PLATFORM_XLIB_KHR or VK_USE_PLATFORM_XCB_KHR
 #elif defined WIN32
     VkIcdSurfaceWin32 *pSurf = (VkIcdSurfaceWin32 *) m_display->get_surface();
     VkWin32SurfaceCreateInfoKHR createInfo;
@@ -3203,10 +3214,16 @@ VkBool32 vkReplay::manually_replay_vkGetPhysicalDeviceXlibPresentationSupportKHR
         return VK_FALSE;
     }
 
-#if defined PLATFORM_LINUX
+#if defined PLATFORM_LINUX && defined VK_USE_PLATFORM_XLIB_KHR
     VkIcdSurfaceXlib *pSurf = (VkIcdSurfaceXlib *) m_display->get_surface();
     m_display->get_window_handle();
     return (m_vkFuncs.real_vkGetPhysicalDeviceXlibPresentationSupportKHR(remappedphysicalDevice, pPacket->queueFamilyIndex, pSurf->dpy, m_display->get_screen_handle()->root_visual));
+#elif defined PLATFORM_LINUX && defined VK_USE_PLATFORM_XCB_KHR
+    VkIcdSurfaceXcb *pSurf = (VkIcdSurfaceXcb *) m_display->get_surface();
+    m_display->get_window_handle();
+    return (m_vkFuncs.real_vkGetPhysicalDeviceXcbPresentationSupportKHR(remappedphysicalDevice, pPacket->queueFamilyIndex, pSurf->connection, m_display->get_screen_handle()->root_visual));
+#elif defined PLATFORM_LINUX
+#error manually_replay_vkGetPhysicalDeviceXlibPresentationSupportKHR on PLATFORM_LINUX requires one of VK_USE_PLATFORM_XLIB_KHR or VK_USE_PLATFORM_XCB_KHR
 #elif defined WIN32
     return (m_vkFuncs.real_vkGetPhysicalDeviceWin32PresentationSupportKHR(remappedphysicalDevice, pPacket->queueFamilyIndex));
 #else
diff --git a/vktrace/vktrace_generate.py b/vktrace/vktrace_generate.py
index 85879b5..ab59294 100755
--- a/vktrace/vktrace_generate.py
+++ b/vktrace/vktrace_generate.py
@@ -117,9 +117,14 @@ class Subcommand(object):
         func_protos.append('extern"C" {')
         func_protos.append('#endif')
         func_protos.append('// Hooked function prototypes\\n')
-        for proto in self.protos:
-            if proto.name not in proto_exclusions:
-                func_protos.append('VKTRACER_EXPORT %s;' % proto.c_func(prefix="__HOOKED_vk", attr="VKAPI"))
+        for ext in vulkan.extensions_all:
+            if ext.ifdef:
+                func_protos.append('#ifdef %s' % ext.ifdef)
+            for proto in ext.protos:
+                if proto.name not in proto_exclusions:
+                    func_protos.append('VKTRACER_EXPORT %s;' % proto.c_func(prefix="__HOOKED_vk", attr="VKAPI"))
+            if ext.ifdef:
+                func_protos.append('#endif /* %s */' % ext.ifdef)
 
         func_protos.append('#ifdef __cplusplus')
         func_protos.append('}')
@@ -131,9 +136,13 @@ class Subcommand(object):
         func_protos.append('// Hooked function prototypes\\n')
         for ext in vulkan.extensions_all:
             if (extensionName.lower() == ext.name.lower()):
+                if ext.ifdef:
+                    func_protos.append('#ifdef %s' % ext.ifdef)
                 for proto in ext.protos:
                     if proto.name not in proto_exclusions:
                         func_protos.append('VKTRACER_EXPORT %s;' % proto.c_func(prefix="__HOOKED_vk", attr="VKAPI"))
+                if ext.ifdef:
+                    func_protos.append('#endif /* %s */' % ext.ifdef)
 
         return "\\n".join(func_protos)
 
@@ -1109,6 +1118,8 @@ class Subcommand(object):
         custom_case_dict = { }
         for ext in vulkan.extensions_all:
             if ext.name.lower() == extensionName.lower():
+                if ext.ifdef:
+                    if_body.append('#ifdef %s' % ext.ifdef)
                 for proto in ext.protos:
                     if_body.append('typedef struct packet_vk%s {' % proto.name)
                     if_body.append('    vktrace_trace_packet_header* pHeader;')
@@ -1133,6 +1144,8 @@ class Subcommand(object):
                                 if_body.append('    }')
                     if_body.append('    return pPacket;')
                     if_body.append('}\\n')
+                if ext.ifdef:
+                    if_body.append('#endif /* %s */' % ext.ifdef)
         return "\\n".join(if_body)
 
     def _generate_replay_func_ptrs(self):
@@ -1140,15 +1153,20 @@ class Subcommand(object):
         xf_body.append('struct vkFuncs {')
         xf_body.append('    void init_funcs(void * libHandle);')
         xf_body.append('    void *m_libHandle;\\n')
-        for proto in self.protos:
-            if proto.name in proto_exclusions:
-                continue
+        for ext in vulkan.extensions_all:
+            if ext.ifdef:
+                xf_body.append('#ifdef %s' % ext.ifdef)
+            for proto in ext.protos:
+                if proto.name in proto_exclusions:
+                    continue
 
-            xf_body.append('    typedef %s( VKAPI_PTR * type_vk%s)(' % (proto.ret, proto.name))
-            for p in proto.params:
-                xf_body.append('        %s,' % p.c())
-            xf_body[-1] = xf_body[-1].replace(',', ');')
-            xf_body.append('    type_vk%s real_vk%s;' % (proto.name, proto.name))
+                xf_body.append('    typedef %s( VKAPI_PTR * type_vk%s)(' % (proto.ret, proto.name))
+                for p in proto.params:
+                    xf_body.append('        %s,' % p.c())
+                xf_body[-1] = xf_body[-1].replace(',', ');')
+                xf_body.append('    type_vk%s real_vk%s;' % (proto.name, proto.name))
+            if ext.ifdef:
+                xf_body.append('#endif /* %s */' % ext.ifdef)
         xf_body.append('};')
         return "\\n".join(xf_body)
 
@@ -1477,13 +1495,18 @@ class Subcommand(object):
     def _generate_replay_init_funcs(self):
         rif_body = []
         rif_body.append('void vkFuncs::init_funcs(void * handle)\\n{\\n    m_libHandle = handle;')
-        for proto in self.protos:
-            if proto.name in proto_exclusions:
-                continue
-            if 'DebugReport' not in proto.name:
-                rif_body.append('    real_vk%s = (type_vk%s)(vktrace_platform_get_library_entrypoint(handle, "vk%s"));' % (proto.name, proto.name, proto.name))
-            else: # These func ptrs get assigned at GetProcAddr time
-                rif_body.append('    real_vk%s = (type_vk%s)NULL;' % (proto.name, proto.name))
+        for ext in vulkan.extensions_all:
+            if ext.ifdef:
+                rif_body.append('#ifdef %s' % ext.ifdef)
+            for proto in ext.protos:
+                if proto.name in proto_exclusions:
+                    continue
+                if 'DebugReport' not in proto.name:
+                    rif_body.append('    real_vk%s = (type_vk%s)(vktrace_platform_get_library_entrypoint(handle, "vk%s"));' % (proto.name, proto.name, proto.name))
+                else: # These func ptrs get assigned at GetProcAddr time
+                    rif_body.append('    real_vk%s = (type_vk%s)NULL;' % (proto.name, proto.name))
+            if ext.ifdef:
+                rif_body.append('#endif /* %s */' % ext.ifdef)
         rif_body.append('}')
         return "\\n".join(rif_body)
 
@@ -1725,6 +1748,20 @@ class Subcommand(object):
             if proto.name in proto_exclusions:
                 continue
 
+            # TODO : This is an O(N^4) way of finding if this proto is guarded by an ifdef.
+            # If the concept of an ifdef field is ok, rewrite the outer loop to already have the ext.ifdef value ready:
+            # for ext in vulkan.extensions_all:
+            #     if ext.ifdef: if_body.append('#ifdef') # wrap all the protos in a single #ifdef block instead of repeating #ifdef for each proto
+            #     for proto in ext.protos:
+            proto_ext_ifdef = None
+            for ext in vulkan.extensions_all:
+                if ext.ifdef:
+                    for ext_proto in ext.protos:
+                        if proto.name == ext_proto.name:
+                            proto_ext_ifdef = ext.ifdef
+            if proto_ext_ifdef:
+                rbody.append('#ifdef %s' % proto_ext_ifdef)
+
             ret_value = False
             create_view = False
             create_func = False
@@ -1831,17 +1868,22 @@ class Subcommand(object):
                     rbody.append('            }')
                 # TODO: need a better way to indicate which extensions should be mapped to which Get*ProcAddr
                 elif proto.name == 'GetInstanceProcAddr':
-                    for iProto in self.protos:
-                        if iProto.name in proto_exclusions:
-                            continue
-                        if 'DebugReport' in iProto.name:
-                            rbody.append('            if (strcmp(pPacket->pName, "vk%s") == 0) {' % (iProto.name))
-                            rbody.append('               m_vkFuncs.real_vk%s = (PFN_vk%s)vk%s(remappedinstance, pPacket->pName);' % (iProto.name, iProto.name, proto.name))
-                            rbody.append('            }')
-                        elif  (iProto.params[0].ty == 'VkInstance' or iProto.params[0].ty != 'VkPhysicalDevice')  and 'KHR' in iProto.name:
-                            rbody.append('            if (strcmp(pPacket->pName, "vk%s") == 0) {' % (iProto.name))
-                            rbody.append('               m_vkFuncs.real_vk%s = (PFN_vk%s)vk%s(remappedinstance, pPacket->pName);' % (iProto.name, iProto.name, proto.name))
-                            rbody.append('            }')
+                    for iExt in vulkan.extensions_all:
+                        if iExt.ifdef:
+                            rbody.append('#ifdef %s' % iExt.ifdef)
+                        for iProto in iExt.protos:
+                            if iProto.name in proto_exclusions:
+                                continue
+                            if 'DebugReport' in iProto.name:
+                                rbody.append('            if (strcmp(pPacket->pName, "vk%s") == 0) {' % (iProto.name))
+                                rbody.append('               m_vkFuncs.real_vk%s = (PFN_vk%s)vk%s(remappedinstance, pPacket->pName);' % (iProto.name, iProto.name, proto.name))
+                                rbody.append('            }')
+                            elif  (iProto.params[0].ty == 'VkInstance' or iProto.params[0].ty != 'VkPhysicalDevice')  and 'KHR' in iProto.name:
+                                rbody.append('            if (strcmp(pPacket->pName, "vk%s") == 0) {' % (iProto.name))
+                                rbody.append('               m_vkFuncs.real_vk%s = (PFN_vk%s)vk%s(remappedinstance, pPacket->pName);' % (iProto.name, iProto.name, proto.name))
+                                rbody.append('            }')
+                        if iExt.ifdef:
+                            rbody.append('#endif /* %s */' % iExt.ifdef)
                 elif proto.name == 'GetDeviceProcAddr':
                     for dProto in self.protos:
                        if dProto.name in proto_exclusions:
@@ -1959,6 +2001,8 @@ class Subcommand(object):
                 rbody.append('            CHECK_RETURN_VALUE(vk%s);' % proto.name)
             rbody.append('            break;')
             rbody.append('        }')
+            if proto_ext_ifdef:
+                rbody.append('#endif /* %s */' % proto_ext_ifdef)
         rbody.append('        default:')
         rbody.append('            vktrace_LogWarning("Unrecognized packet_id %u, skipping.", packet->packet_id);')
         rbody.append('            returnValue = vktrace_replay::VKTRACE_REPLAY_INVALID_ID;')
diff --git a/vulkan.py b/vulkan.py
index 97d8706..4a9b796 100644
--- a/vulkan.py
+++ b/vulkan.py
@@ -159,11 +159,12 @@ class Proto(object):
                 (self.ret, self.name, param_str)
 
 class Extension(object):
-    def __init__(self, name, headers, objects, protos):
+    def __init__(self, name, headers, objects, protos, ifdef = None):
         self.name = name
         self.headers = headers
         self.objects = objects
         self.protos = protos
+        self.ifdef = ifdef
 
     def __repr__(self):
         lines = []
@@ -1160,6 +1161,7 @@ ext_khr_xlib_surface = Extension(
     name="VK_KHR_xlib_surface",
     headers=["vulkan/vulkan.h"],
     objects=[],
+    ifdef="VK_USE_PLATFORM_XLIB_KHR",
     protos=[
         Proto("VkResult", "CreateXlibSurfaceKHR",
             [Param("VkInstance", "instance"),
EOF







  #
  # install VkLayer files that are VulkanTools layers
  # (VulkanTools is built on Vulkan-LoaderAndValidationLayers and re-builds dups of those layers)
  #
  patch -p1 <<EOF
diff --git a/layersvt/CMakeLists.txt b/layersvt/CMakeLists.txt
index 32ee1c4..b6414c3 100644
--- a/layersvt/CMakeLists.txt
+++ b/layersvt/CMakeLists.txt
@@ -65,6 +65,11 @@ else()
                 )
         endforeach(config_file)
     endif()
+    foreach (config_file \${LAYER_JSON_FILES})
+        install (FILES \${CMAKE_CURRENT_SOURCE_DIR}/linux/\${config_file}.json
+            DESTINATION etc/vulkan/explicit_layer.d
+            )
+    endforeach(config_file)
 endif()
 
 if (WIN32)
@@ -83,8 +88,11 @@ else()
     add_library(VkLayer_\${target} SHARED \${ARGN})
     target_link_Libraries(VkLayer_\${target} VkLayer_utilsvt)
     add_dependencies(VkLayer_\${target} generate_vt_helpers)
-    set_target_properties(VkLayer_\${target} PROPERTIES LINK_FLAGS "-Wl,-Bsymbolic")
+    set_target_properties(VkLayer_\${target}
+        PROPERTIES LINK_FLAGS "-Wl,-Bsymbolic"
+            INSTALL_RPATH \${CMAKE_INSTALL_PREFIX}/etc/vulkan/explicit_layer.d)
     install(TARGETS VkLayer_\${target} DESTINATION \${PROJECT_BINARY_DIR}/install_staging)
+    install(TARGETS VkLayer_\${target} DESTINATION etc/vulkan/explicit_layer.d)
     endmacro()
 endif()
 
diff --git a/vktrace/src/vktrace_layer/CMakeLists.txt b/vktrace/src/vktrace_layer/CMakeLists.txt
index c2f5d35..b6f5c1d 100644
--- a/vktrace/src/vktrace_layer/CMakeLists.txt
+++ b/vktrace/src/vktrace_layer/CMakeLists.txt
@@ -86,15 +86,16 @@ include_directories(
 # copy/link layer json file into build/layersvt directory
 if (NOT WIN32)
     # extra setup for out-of-tree builds
+    FILE(TO_NATIVE_PATH \${CMAKE_CURRENT_SOURCE_DIR}/linux/VkLayer_vktrace_layer.json src_json)
     if (NOT (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR))
         add_custom_target(vktrace_layer-json ALL
-            COMMAND ln -sf \${CMAKE_CURRENT_SOURCE_DIR}/linux/VkLayer_vktrace_layer.json \${CMAKE_RUNTIME_OUTPUT_DIRECTORY}../layersvt/
+            COMMAND ln -sf \${src_json} \${CMAKE_RUNTIME_OUTPUT_DIRECTORY}../layersvt/
             VERBATIM
             )
     endif()
 else()
+    FILE(TO_NATIVE_PATH \${CMAKE_CURRENT_SOURCE_DIR}/windows/VkLayer_vktrace_layer.json src_json)
     if (NOT (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR))
-        FILE(TO_NATIVE_PATH \${CMAKE_CURRENT_SOURCE_DIR}/windows/VkLayer_vktrace_layer.json src_json)
         if (CMAKE_GENERATOR MATCHES "^Visual Studio.*")
             FILE(TO_NATIVE_PATH \${PROJECT_BINARY_DIR}/../../../layersvt/\$<CONFIGURATION>/VkLayer_vktrace_layer.json dst_json)
         else()
@@ -134,4 +135,9 @@ target_link_libraries(\${PROJECT_NAME}
 
 build_options_finalize()
 
-set_target_properties(VkLayer_vktrace_layer PROPERTIES LINKER_LANGUAGE C)
+set_target_properties(VkLayer_vktrace_layer
+    PROPERTIES LINKER_LANGUAGE C
+    INSTALL_RPATH \${CMAKE_INSTALL_PREFIX}/etc/vulkan/explicit_layer.d )
+
+install (FILES \${src_json} DESTINATION etc/vulkan/explicit_layer.d)
+install(TARGETS VkLayer_vktrace_layer DESTINATION etc/vulkan/explicit_layer.d)
diff --git a/vktrace/src/vktrace_layer/linux/VkLayer_vktrace_layer.json b/vktrace/src/vktrace_layer/linux/VkLayer_vktrace_layer.json
index 0dcdc6b..07661f8 100644
--- a/vktrace/src/vktrace_layer/linux/VkLayer_vktrace_layer.json
+++ b/vktrace/src/vktrace_layer/linux/VkLayer_vktrace_layer.json
@@ -3,7 +3,7 @@
     "layer" : {
         "name": "VK_LAYER_LUNARG_vktrace",
         "type": "GLOBAL",
-        "library_path": "../vktrace/libVkLayer_vktrace_layer.so",
+        "library_path": "./libVkLayer_vktrace_layer.so",
         "api_version": "1.0.21",
         "implementation_version": "1",
         "description": "Vktrace tracing library",
EOF







  #
  # install binaries
  #
  patch -p1 <<EOF
diff --git a/vktrace/src/vktrace_replay/CMakeLists.txt b/vktrace/src/vktrace_replay/CMakeLists.txt
index 5bc1807..fff729a 100644
--- a/vktrace/src/vktrace_replay/CMakeLists.txt
+++ b/vktrace/src/vktrace_replay/CMakeLists.txt
@@ -28,4 +28,10 @@ target_link_libraries(\${PROJECT_NAME}
     \${LIBRARIES}
 )
 
+if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+  set_target_properties(\${PROJECT_NAME} PROPERTIES
+      INSTALL_RPATH "\\\$ORIGIN/../VulkanSamples/build/loader")
+  install(TARGETS \${PROJECT_NAME} DESTINATION bin)
+endif()
+
 build_options_finalize()
diff --git a/vktrace/src/vktrace_trace/CMakeLists.txt b/vktrace/src/vktrace_trace/CMakeLists.txt
index 63ba576..6cb921e 100644
--- a/vktrace/src/vktrace_trace/CMakeLists.txt
+++ b/vktrace/src/vktrace_trace/CMakeLists.txt
@@ -24,4 +24,8 @@ target_link_libraries(\${PROJECT_NAME}
     vktrace_common
 )
 
+if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+  install(TARGETS \${PROJECT_NAME} DESTINATION bin)
+endif()
+
 build_options_finalize()
diff --git a/vktrace/src/vktrace_viewer/CMakeLists.txt b/vktrace/src/vktrace_viewer/CMakeLists.txt
index 5dfa5f8..58d2392 100644
--- a/vktrace/src/vktrace_viewer/CMakeLists.txt
+++ b/vktrace/src/vktrace_viewer/CMakeLists.txt
@@ -162,6 +162,10 @@ if (MSVC)
                     COMMENT "Copying vktraceviewer Qt5 dependencies to \${COPY_DEST}"
                     VERBATIM)
 
+else()
+  set_target_properties(\${PROJECT_NAME} PROPERTIES
+      INSTALL_RPATH "\\\$ORIGIN/../VulkanSamples/build/loader")
+  install(TARGETS \${PROJECT_NAME} DESTINATION bin)
 endif()
 
 build_options_finalize()
EOF


  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Debug "-DCMAKE_INSTALL_PREFIX=${PREFIX}" -DBUILD_WSI_XLIB_SUPPORT=Off -DBUILD_VKTRACEVIEWER=On
  cd build
  make -j $(nproc) install
)
