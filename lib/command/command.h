/* Copyright (c) David Hubbard 2016. Licensed under the GPLv3.
 *
 * lib/command is the 3rd-level bindings for the Vulkan graphics library.
 * lib/command is part of the v0lum3 project.
 * This library is called "command" as a homage to Star Trek First Contact.
 * Like the Vulcan High Command, this library sends out the commands.
 *
 * This library has 3 sub-categories, all interdependent:
 *
 * 1. The RenderPass uses these classes:
 *    * RenderPass
 *    * Pipeline
 *    * PipelineCreateInfo
 *    * PipelineStage
 *    * Shader
 *
 * 2. The Semaphore (with PresentSemaphore), Fence, and Event classes.
 *
 * 3. The CommandPool and CommandBuilder classes.
 */

#include <lib/language/VkInit.h>
#include <lib/language/VkPtr.h>
#include <lib/language/language.h>
#include <vulkan/vulkan.h>
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/VulkanSamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>
#include <memory>
#include <set>
#include <string>

#pragma once

namespace command {

// Shader represents the compiled SPIR-V code generated by glslangVerifier.
// To add your Shader objects to a Pipeline:
// 1. Allocate the Shader:
//    auto shader = std::shared_ptr<command::Shader>(new command::Shader(dev));
// 2. Load the SPIR-V code from a file (or somewhere else):
//    if (shader->loadSPV("filename.spv")) { ... }
// 3. Call PipelineCreateInfo::addShader(shader), which will also add the
//    shader to the RenderPass.
//
// Or a simpler approach is to use science::ShaderLibrary.
typedef struct Shader {
  Shader(language::Device& dev)
      : vkdev{dev.dev}, vk{dev.dev, vkDestroyShaderModule} {
    vk.allocator = dev.dev.allocator;
  }
  Shader(Shader&&) = default;
  Shader(const Shader& other) = delete;

  WARN_UNUSED_RESULT int loadSPV(const void* spvBegin, const void* spvEnd);
  WARN_UNUSED_RESULT int loadSPV(const void* spvBegin, size_t len) {
    return loadSPV(spvBegin, (const char*)spvBegin + len);
  }
  WARN_UNUSED_RESULT int loadSPV(const std::vector<char>& spv) {
    return loadSPV(&*spv.begin(), &*spv.end());
  }
  WARN_UNUSED_RESULT int loadSPV(const std::vector<uint32_t>& spv) {
    return loadSPV(&*spv.begin(), &*spv.end());
  }
  WARN_UNUSED_RESULT int loadSPV(const char* filename);
  WARN_UNUSED_RESULT int loadSPV(std::string filename) {
    return loadSPV(filename.c_str());
  }

  VkDevice vkdev;
  VkPtr<VkShaderModule> vk;
} Shader;

// PipelineAttachment constructs a VkAttachmentDescription. When it is added to
// the VkRenderPassCreateInfo in RenderPass::ctorError(), it is given an index
// -- written to VkAttachmentReference refvk here. The refvk is then added to
// the PipelineCreateInfo::subpassDesc.
typedef struct PipelineAttachment {
  // Construct a PipelineAttachment which corresponds to a
  // Framebuffer attachment with the given VkFormat and VkImageLayout.
  PipelineAttachment(language::Device& dev, VkFormat format,
                     VkImageLayout refLayout);

  VkAttachmentReference refvk;
  VkAttachmentDescription vk;
} PipelineAttachment;

// PipelineStage is the entrypoint to run a Shader as one of the programmable
// pipeline stages. (See the description of Pipeline, below.)
//
// PipelineStage::entryPoint sets what function is "main()" in the Shader.
// A library of useful code can be built as a single large shader with several
// entryPointNames -- glslangVerifier can build many source files as one unit.
//
// Or, keep it simple: set entryPointName = "main" on all your shaders to make
// them feel like "C".
//
// TODO: Find out if Vulkan errors out if two PipelineStages are added for the
// same stage. For example, two VK_SHADER_STAGE_VERTEX_BIT.
typedef struct PipelineStage {
  PipelineStage() { VkOverwrite(info); }
  PipelineStage(PipelineStage&&) = default;
  PipelineStage(const PipelineStage&) = default;

  std::shared_ptr<Shader> shader;
  std::string entryPointName;

  // You must initialize info.flag, but do not initialize
  // info.module and info.pName. They will be written by Pipeline::init().
  VkPipelineShaderStageCreateInfo info;
} PipelineStage;

// Forward declaration of RenderPass for Pipeline and PipelineCreateInfo.
struct RenderPass;

// Vulkan defines a render pipeline in terms of the following stages:
// 1. Input assembly: fixed function, reads input data.
// 2. Vertex shader: programmable, operates on input vertices, uniforms, etc.
// 3. Tesselation shader: programmable, reads the vertex shader's output and
//    produces a different number of vertices.
// 4. Geometry shader: programmable. Most GPUs cannot do geometry shading with
//    reasonable performance (the notable exception is Intel).
// 5. Rasterizer: fixed function, draws triangles / lines / points.
// 6. Fragment shader: programmable, operates on each "fragment" (each pixel).
// 7. Color blend: fixed function, writes fragments to the frame buffer.
//
// Use Pipeline in the following order:
// 1. Instantiate a Pipeline with a Device dev.
// 2. Customize the Pipeline::info, including calling addShader().
// 3. Call RenderPass:ctorError() to create the vulkan objects.
typedef struct PipelineCreateInfo {
  PipelineCreateInfo(language::Device& dev);
  PipelineCreateInfo(PipelineCreateInfo&&) = default;
  PipelineCreateInfo(const PipelineCreateInfo& other) = default;

  std::vector<PipelineStage> stages;

  // addShader adds a PipelineStage to stages, holding a reference to it
  // in renderPass (for de-duplication).
  //
  // stageBits define which stage(s) the shader is valid for (vertex shader,
  // fragment shader, etc.)
  //
  // entryPointName defines what "main" function to run.
  WARN_UNUSED_RESULT int addShader(std::shared_ptr<Shader> shader,
                                   language::Device& dev,
                                   RenderPass& renderPass,
                                   VkShaderStageFlagBits stageBits,
                                   std::string entryPointName = "main");

  // Helper function to create a blend state of "just write these pixels."
  static VkPipelineColorBlendAttachmentState withDisabledAlpha();

  // Helper function to create a blend state "do normal RGBA alpha blending."
  static VkPipelineColorBlendAttachmentState withEnabledAlpha();

  // Optionally modify these structures before calling RenderPass::ctorError().
  VkPipelineVertexInputStateCreateInfo vertsci;
  VkPipelineInputAssemblyStateCreateInfo asci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // viewports and scissors will be written to viewsci by Pipeline::init().
  // Optionally update the viewports and scissors in-place and use them in
  // CommandBuilder::setViewport() and CommandBuilder::setScissor()
  std::vector<VkViewport> viewports;
  std::vector<VkRect2D> scissors;
  VkPipelineViewportStateCreateInfo viewsci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  VkPipelineRasterizationStateCreateInfo rastersci;
  VkPipelineMultisampleStateCreateInfo multisci;
  VkPipelineDepthStencilStateCreateInfo depthsci;

  // Use vkCreateDescriptorSetLayout to create layouts, which then
  // auto-generates VkPipelineLayoutCreateInfo.
  // TODO: Add pushConstants.
  std::vector<VkDescriptorSetLayout> setLayouts;

  std::vector<VkDynamicState> dynamicStates;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // perFramebufColorBlend will be written to cbsci by Pipeline::init().
  std::vector<VkPipelineColorBlendAttachmentState> perFramebufColorBlend;
  VkPipelineColorBlendStateCreateInfo cbsci;

  // Optionally modify these structures before calling RenderPass::ctorError().
  // The PipelineAttachment::VkAttachmentReference::attachment index is set by
  // RenderPass::ctorError(), then written to PipelineCreateInfo::subpassDesc.
  std::vector<PipelineAttachment> attach;

  VkSubpassDescription subpassDesc;
} PipelineCreateInfo;

// Pipeline represents a VkPipeline and VkPipelineLayout pair.
typedef struct Pipeline {
  Pipeline(language::Device& dev);
  Pipeline(Pipeline&&) = default;
  Pipeline(const Pipeline& other) = delete;
  virtual ~Pipeline();

  PipelineCreateInfo info;

  VkPtr<VkPipelineLayout> pipelineLayout;
  VkPtr<VkPipeline> vk;

 protected:
  friend struct RenderPass;
  // Workaround bug in NVidia driver that driver does not keep a copy of the
  // VkPipelineShaderStageCreateInfo pName contents, just the pointer.
  std::vector<std::string> stageName;

  // init() sets up shaders (and references to them in info.stages), and
  // creates a VkPipeline. The parent renderPass and this Pipeline's
  // index in it are passed in as parameters. This method should be
  // called by RenderPass::ctorError().
  WARN_UNUSED_RESULT virtual int init(language::Device& dev,
                                      RenderPass& renderPass, size_t subpass_i);
} Pipeline;

// RenderPass is the main object to set up and control presenting pixels to the
// screen.
//
// To create a RenderPass:
// 1. Instantiate the RenderPass: RenderPass rp(dev);
// 2. Add each Pipeline:          rp.pipelines.emplace_back(dev, rp);
//    and customize the Pipeline to suit your application.
// 3. Instantiate and load the SPV binary code into the shaders:
//    auto& vs = rp.pipelines.at(0).addShader(rp, VK_SHADER_STAGE_VERTEX_BIT,
//        "main");
//    vs.loadSPV(...);
//    // vs becomes invalid when .addShader() is called again.
//    auto& fs = rp.pipelines.at(0).addShader(rp, VK_SHADER_STAGE_FRAGMENT_BIT,
//        "main");
//    fs.loadSPV(...);
// 4. Init the renderPass.
//        if (renderPass.init(dev) { ... handle errors ... }
typedef struct RenderPass {
  RenderPass(language::Device& dev) : vk{dev.dev, vkDestroyRenderPass} {
    VkOverwrite(rpci);
    VkOverwrite(passBeginInfo);
    passBeginClearColors.emplace_back();
    setClearColor(0.0f, 0.0f, 0.0f, 1.0f);
  }
  RenderPass(RenderPass&&) = default;
  RenderPass(const RenderPass&) = delete;
  virtual ~RenderPass() = default;

  std::set<std::shared_ptr<Shader>> shaders;
  std::vector<Pipeline> pipelines;

  // addPipeline is a convenience method for adding a pipeline.
  Pipeline& addPipeline(language::Device& dev) {
    pipelines.emplace_back(dev);
    return *(pipelines.end() - 1);
  }

  VkRenderPassCreateInfo rpci;

  // Override this function to customize the subpass dependencies.
  // The default just executes subpasses serially (in order).
  WARN_UNUSED_RESULT virtual int getSubpassDeps(
      size_t subpass_i, std::vector<VkSubpassDependency>& subpassdeps);

  // ctorError() initializes each pipeline with their PipelineCreateInfo info.
  WARN_UNUSED_RESULT int ctorError(language::Device& dev);

  VkPtr<VkRenderPass> vk;

  // passBeginInfo is populated by ctorError(). Customize it as needed.
  // Note that YOU MUST update passBeginInfo.frameBuffer each frame -- it is not
  // something ctorError() can set for you. And YOU MUST set
  // passBeginInfo.renderArea.extent any time the window is resized.
  // CommandBuilder::beginRenderPass() assumes you have correctly set
  // passBeginInfo.
  VkRenderPassBeginInfo passBeginInfo;

  // passBeginClearColors is referenced in passBeginInfo.
  std::vector<VkClearValue> passBeginClearColors;

  // setClearColor is a helper method to quickly update passBeginClearColors.
  // passBeginClearColors is used by ctorError() to populate passBeginInfo.
  // Calling setClearColor() after ctorError() will have no effect.
  void setClearColor(float r, float g, float b, float a = 1.0f) {
    passBeginClearColors.at(0).color = {r, g, b, a};
  }
} RenderPass;

// Semaphore represents a GPU-only synchronization operation vs. Fence, below.
// Semaphores can be waited on in any queue vs. Events which must be waited on
// within a single queue.
typedef struct Semaphore {
  Semaphore(language::Device& dev) : vk{dev.dev, vkDestroySemaphore} {
    vk.allocator = dev.dev.allocator;
  }
  // Two-stage constructor: check the return code of ctorError().
  WARN_UNUSED_RESULT int ctorError(language::Device& dev);

  VkPtr<VkSemaphore> vk;
} Semaphore;

// PresentSemaphore is a special Semaphore that adds the present() method.
class PresentSemaphore : public Semaphore {
 public:
  language::Device& dev;
  VkQueue q;

 public:
  PresentSemaphore(language::Device& dev) : Semaphore(dev), dev(dev) {}
  PresentSemaphore(PresentSemaphore&&) = default;
  PresentSemaphore(const PresentSemaphore&) = delete;

  // Two-stage constructor: check the return code of ctorError().
  WARN_UNUSED_RESULT int ctorError();

  // present() submits the given swapChain image_i to Device dev's screen
  // using the correct language::PRESENT queue and synchronization.
  WARN_UNUSED_RESULT int present(uint32_t image_i);
};

// Fence represents a GPU-to-CPU synchronization. Fences are the only sync
// primitive which the CPU can wait on.
typedef struct Fence {
  Fence(language::Device& dev) : vk{dev.dev, vkDestroyFence} {
    vk.allocator = dev.dev.allocator;
  }
  // Two-stage constructor: check the return code of ctorError().
  WARN_UNUSED_RESULT int ctorError(language::Device& dev);

  VkPtr<VkFence> vk;
} Fence;

// Event represents a GPU-only synchronization operation, and must be waited on
// and set (signalled) within a single queue. Events can also be set (signalled)
// from the CPU.
typedef struct Event {
  Event(language::Device& dev) : vk{dev.dev, vkDestroyEvent} {
    vk.allocator = dev.dev.allocator;
  }
  // Two-stage constructor: check the return code of ctorError().
  WARN_UNUSED_RESULT int ctorError(language::Device& dev);

  VkPtr<VkEvent> vk;
} Event;

// CommandPool holds a reference to the VkCommandPool from which commands are
// allocated. Create a CommandPool instance in each thread that submits
// commands to qfam_i.
class CommandPool {
 protected:
  language::QueueFamily* qf_ = nullptr;
  VkDevice vkdev;

 public:
  CommandPool(language::Device& dev, language::SurfaceSupport queueFamily)
      : vkdev(dev.dev),
        queueFamily(queueFamily),
        vk{dev.dev, vkDestroyCommandPool} {
    vk.allocator = dev.dev.allocator;
  }
  CommandPool(CommandPool&&) = default;
  CommandPool(const CommandPool&) = delete;

  // Two-stage constructor: check the return code of ctorError().
  WARN_UNUSED_RESULT int ctorError(
      language::Device& dev,
      VkCommandPoolCreateFlags flags =
          VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |
          VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);

  VkQueue q(size_t i) { return qf_->queues.at(i); }

  // free releases any VkCommandBuffer in buf. Command Buffers are automatically
  // freed when the CommandPool is destroyed, so free() is really only needed
  // when dynamically replacing an existing set of CommandBuffers.
  void free(std::vector<VkCommandBuffer>& buf) {
    if (!buf.size()) return;
    vkFreeCommandBuffers(vkdev, vk, buf.size(), buf.data());
  }

  // alloc calls vkAllocateCommandBuffers to populate buf with empty buffers.
  // Specify the VkCommandBufferLevel for a secondary command buffer.
  WARN_UNUSED_RESULT int alloc(
      std::vector<VkCommandBuffer>& buf,
      VkCommandBufferLevel level = VK_COMMAND_BUFFER_LEVEL_PRIMARY);

  // reset deallocates all command buffers in the pool (very quickly).
  WARN_UNUSED_RESULT int reset(
      VkCommandPoolResetFlagBits flags =
          VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT) {
    VkResult v;
    if ((v = vkResetCommandPool(vkdev, vk, flags)) != VK_SUCCESS) {
      fprintf(stderr, "vkResetCommandPool failed: %d (%s)\n", v,
              string_VkResult(v));
      return 1;
    }
    return 0;
  }

  const language::SurfaceSupport queueFamily;
  VkPtr<VkCommandPool> vk;
};

// CommandBuilder holds a vector of VkCommandBuffer, designed to simplify
// recording, executing, and reusing a VkCommandBuffer. A vector of
// VkCommandBuffers is more useful because one buffer may be executing while
// your application is recording into another (or similar designs). The
// CommandBuilder::use() method selects which VkCommandBuffer gets recorded
// or "built."
// https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/html/vkspec.html#commandbuffers-lifecycle
//
// Static command buffers can also be built using this class; your application
// may still need the vector of many VkCommandBuffers because each one will
// bind to the renderPass (passBeginInfo contains a reference to a framebuffer,
// which must be set up for each framebuffer in the swapChain).
//
// TODO: describe how to use a secondary command buffer for static draw calls.
class CommandBuilder {
 protected:
  CommandPool& cpool;
  bool isAllocated = false;
  size_t bufInUse = 0;
  VkCommandBuffer buf = VK_NULL_HANDLE;

  int alloc() {
    if (cpool.alloc(bufs)) {
      return 1;
    }
    isAllocated = true;
    use(bufInUse);
    return 0;
  }

 public:
  CommandBuilder(CommandPool& cpool_, size_t initialSize = 1)
      : cpool(cpool_), bufs(initialSize) {}
  ~CommandBuilder();

  std::vector<VkCommandBuffer> bufs;

  // resize updates the vector size and reallocates the VkCommandBuffers.
  WARN_UNUSED_RESULT int resize(size_t bufsSize) {
    if (isAllocated) {
      // free any VkCommandBuffer in buf. Command Buffers are automatically
      // freed when the CommandPool is destroyed, so free() is really only
      // needed when dynamically replacing an existing set of CommandBuffers.
      cpool.free(bufs);
    }
    bufs.resize(bufsSize);
    return alloc();
  }

  // use selects which index in the vector bufs gets recorded or "built."
  // The first VkCommandBuffer is selected by default, to simplify cases where
  // only one CommandBuffer is needed.
  void use(size_t i) {
    bufInUse = i;
    buf = bufs.at(i);
  }

  // submit calls vkQueueSubmit using commandPoolQueueI.
  // Note vkQueueSubmit is a high overhead operation; submitting multiple
  // command buffers and even multiple VkSubmitInfo batches is recommended --
  // see submitMany.
  //
  // An optional VkFence parameter can be specified to signal the VkFence when
  // the operation is complete.
  WARN_UNUSED_RESULT int submit(
      size_t commandPoolQueueI,
      const std::vector<VkSemaphore>& waitSemaphores =
          std::vector<VkSemaphore>(),
      const std::vector<VkPipelineStageFlags>& waitStages =
          std::vector<VkPipelineStageFlags>(),
      const std::vector<VkSemaphore>& signalSemaphores =
          std::vector<VkSemaphore>(),
      VkFence fence = VK_NULL_HANDLE) {
    if (waitSemaphores.size() != waitStages.size()) {
      fprintf(stderr, "submit: waitSemaphores len=%zu but waitStages len=%zu\n",
              waitSemaphores.size(), waitStages.size());
      return 1;
    }
    VkSubmitInfo VkInit(submitInfo);
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &buf;
    submitInfo.waitSemaphoreCount = waitSemaphores.size();
    submitInfo.pWaitSemaphores = waitSemaphores.data();
    submitInfo.pWaitDstStageMask = waitStages.data();
    submitInfo.signalSemaphoreCount = signalSemaphores.size();
    submitInfo.pSignalSemaphores = signalSemaphores.data();

    VkResult v =
        vkQueueSubmit(cpool.q(commandPoolQueueI), 1, &submitInfo, fence);
    if (v != VK_SUCCESS) {
      fprintf(stderr, "vkQueueSubmit failed: %d (%s)\n", v, string_VkResult(v));
      return 1;
    }
    return 0;
  }

  // submitMany bypasses the typical CommandBuilder::use() and allows raw
  // access to the VkQueueSubmit() call.
  //
  // Note vkQueueSubmit is a high overhead operation. submitMany is the way to
  // submit multiple VkSubmitInfo objects at once.
  //
  // An optional VkFence parameter can be specified to signal the VkFence when
  // the operation is complete.
  WARN_UNUSED_RESULT int submitMany(size_t commandPoolQueueI,
                                    std::vector<VkSubmitInfo> info,
                                    VkFence fence = VK_NULL_HANDLE) {
    VkResult v = vkQueueSubmit(cpool.q(commandPoolQueueI), info.size(),
                               info.data(), fence);
    if (v != VK_SUCCESS) {
      fprintf(stderr, "vkQueueSubmit failed: %d (%s)\n", v, string_VkResult(v));
      return 1;
    }
    return 0;
  }

  // reset deallocates and clears the current VkCommandBuffer. Note that in
  // most cases, begin() calls vkBeginCommandBuffer() which implicitly resets
  // the buffer and clears any old data it may have had.
  WARN_UNUSED_RESULT int reset(
      VkCommandBufferResetFlagBits flags =
          VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT) {
    VkResult v;
    if ((v = vkResetCommandBuffer(buf, flags)) != VK_SUCCESS) {
      fprintf(stderr, "vkResetCommandBuffer failed: %d (%s)\n", v,
              string_VkResult(v));
      return 1;
    }
  }

  WARN_UNUSED_RESULT int begin(VkCommandBufferUsageFlagBits usageFlags) {
    if (!isAllocated && alloc()) {
      return 1;
    }
    VkCommandBufferBeginInfo VkInit(cbbi);
    cbbi.flags = usageFlags;
    VkResult v = vkBeginCommandBuffer(buf, &cbbi);
    if (v != VK_SUCCESS) {
      fprintf(stderr, "vkBeginCommandBuffer failed: %d (%s)\n", v,
              string_VkResult(v));
      return 1;
    }
    return 0;
  }

  WARN_UNUSED_RESULT int beginOneTimeUse() {
    return begin(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT);
  }
  WARN_UNUSED_RESULT int beginSimultaneousUse() {
    return begin(VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT);
  }

  WARN_UNUSED_RESULT int end() {
    if (!isAllocated && alloc()) {
      return 1;
    }
    VkResult v = vkEndCommandBuffer(buf);
    if (v != VK_SUCCESS) {
      fprintf(stderr, "vkEndCommandBuffer failed: %d (%s)\n", v,
              string_VkResult(v));
      return 1;
    }
    return 0;
  }

  WARN_UNUSED_RESULT int executeCommands(uint32_t secondaryCmdsCount,
                                         VkCommandBuffer* pSecondaryCmds) {
    vkCmdExecuteCommands(buf, secondaryCmdsCount, pSecondaryCmds);
    return 0;
  }

  WARN_UNUSED_RESULT int waitEvents(
      uint32_t eventCount, const VkEvent* pEvents,
      VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
      uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
      uint32_t bufferMemoryBarrierCount,
      const VkBufferMemoryBarrier* pBufferMemoryBarriers,
      uint32_t imageMemoryBarrierCount,
      const VkImageMemoryBarrier* pImageMemoryBarriers) {
    vkCmdWaitEvents(buf, eventCount, pEvents, srcStageMask, dstStageMask,
                    memoryBarrierCount, pMemoryBarriers,
                    bufferMemoryBarrierCount, pBufferMemoryBarriers,
                    imageMemoryBarrierCount, pImageMemoryBarriers);
    return 0;
  }

  WARN_UNUSED_RESULT int setEvent(VkEvent event,
                                  VkPipelineStageFlags stageMask) {
    vkCmdSetEvent(buf, event, stageMask);
    return 0;
  }

  WARN_UNUSED_RESULT int resetEvent(VkEvent event,
                                    VkPipelineStageFlags stageMask) {
    vkCmdResetEvent(buf, event, stageMask);
    return 0;
  }

  WARN_UNUSED_RESULT int pushConstants(Pipeline& pipe,
                                       VkShaderStageFlags stageFlags,
                                       uint32_t offset, uint32_t size,
                                       const void* pValues) {
    vkCmdPushConstants(buf, pipe.pipelineLayout, stageFlags, offset, size,
                       pValues);
    return 0;
  }

  WARN_UNUSED_RESULT int fillBuffer(VkBuffer dst, VkDeviceSize dstOffset,
                                    VkDeviceSize size, uint32_t data) {
    vkCmdFillBuffer(buf, dst, dstOffset, size, data);
    return 0;
  }

  WARN_UNUSED_RESULT int updateBuffer(VkBuffer dst, VkDeviceSize dstOffset,
                                      VkDeviceSize dataSize,
                                      const void* pData) {
    vkCmdUpdateBuffer(buf, dst, dstOffset, dataSize, pData);
    return 0;
  }

  WARN_UNUSED_RESULT int copyBuffer(VkBuffer src, VkBuffer dst,
                                    std::vector<VkBufferCopy>& regions) {
    if (regions.size() == 0) {
      fprintf(stderr, "copyBuffer with empty regions\n");
      return 1;
    }
    if (!isAllocated && alloc()) {
      return 1;
    }
    vkCmdCopyBuffer(buf, src, dst, regions.size(), regions.data());
    return 0;
  }
  WARN_UNUSED_RESULT int copyBuffer(VkBuffer src, VkBuffer dst, size_t size) {
    VkBufferCopy region = {};
    region.size = size;
    std::vector<VkBufferCopy> regions{region};
    return copyBuffer(src, dst, regions);
  }

  WARN_UNUSED_RESULT int copyBufferToImage(
      VkBuffer src, VkImage dst, VkImageLayout dstLayout,
      std::vector<VkBufferImageCopy>& regions) {
    vkCmdCopyBufferToImage(buf, src, dst, dstLayout, regions.size(),
                           regions.data());
    return 0;
  }

  WARN_UNUSED_RESULT int copyImageToBuffer(
      VkImage src, VkImageLayout srcLayout, VkBuffer dst,
      std::vector<VkBufferImageCopy>& regions) {
    vkCmdCopyImageToBuffer(buf, src, srcLayout, dst, regions.size(),
                           regions.data());
    return 0;
  }

  WARN_UNUSED_RESULT int copyImage(VkImage src, VkImageLayout srcLayout,
                                   VkImage dst, VkImageLayout dstLayout,
                                   const std::vector<VkImageCopy>& regions) {
    vkCmdCopyImage(buf, src, srcLayout, dst, dstLayout, regions.size(),
                   regions.data());
    return 0;
  }
  WARN_UNUSED_RESULT int copyImage(VkImage src, VkImage dst,
                                   const std::vector<VkImageCopy>& regions) {
    return copyImage(src, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, dst,
                     VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, regions);
  }

  WARN_UNUSED_RESULT int blitImage(VkImage src, VkImageLayout srcLayout,
                                   VkImage dst, VkImageLayout dstLayout,
                                   std::vector<VkImageBlit>& regions,
                                   VkFilter filter) {
    vkCmdBlitImage(buf, src, srcLayout, dst, dstLayout, regions.size(),
                   regions.data(), filter);
    return 0;
  }

  WARN_UNUSED_RESULT int resolveImage(VkImage src, VkImageLayout srcLayout,
                                      VkImage dst, VkImageLayout dstLayout,
                                      std::vector<VkImageResolve>& regions) {
    vkCmdResolveImage(buf, src, srcLayout, dst, dstLayout, regions.size(),
                      regions.data());
    return 0;
  }

  WARN_UNUSED_RESULT int copyQueryPoolResults(
      VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
      VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride,
      VkQueryResultFlags flags) {
    vkCmdCopyQueryPoolResults(buf, queryPool, firstQuery, queryCount, dstBuffer,
                              dstOffset, stride, flags);
    return 0;
  }

  WARN_UNUSED_RESULT int resetQueryPool(VkQueryPool queryPool,
                                        uint32_t firstQuery,
                                        uint32_t queryCount) {
    vkCmdResetQueryPool(buf, queryPool, firstQuery, queryCount);
    return 0;
  }

  WARN_UNUSED_RESULT int beginQuery(VkQueryPool queryPool, uint32_t query,
                                    VkQueryControlFlags flags) {
    vkCmdBeginQuery(buf, queryPool, query, flags);
    return 0;
  }

  WARN_UNUSED_RESULT int endQuery(VkQueryPool queryPool, uint32_t query) {
    vkCmdEndQuery(buf, queryPool, query);
    return 0;
  }

  WARN_UNUSED_RESULT int writeTimestamp(VkPipelineStageFlagBits stage,
                                        VkQueryPool queryPool, uint32_t query) {
    vkCmdWriteTimestamp(buf, stage, queryPool, query);
    return 0;
  }

  WARN_UNUSED_RESULT int beginRenderPass(RenderPass& pass,
                                         VkSubpassContents contents) {
    if (!pass.passBeginInfo.framebuffer) {
      fprintf(stderr,
              "beginRenderPass: framebuffer was not set to one of "
              "Device::framebufs.\n");
      return 1;
    }
    vkCmdBeginRenderPass(buf, &pass.passBeginInfo, contents);
    return 0;
  }
  // beginPrimaryPass starts a RenderPass using a primary command buffer.
  WARN_UNUSED_RESULT int beginPrimaryPass(RenderPass& pass) {
    return beginRenderPass(pass, VK_SUBPASS_CONTENTS_INLINE);
  }
  // beginSecondaryPass is necessary to bind a secondary command buffer to
  // its associated RenderPass even though it will be called from the correct
  // primary command buffer.
  WARN_UNUSED_RESULT int beginSecondaryPass(RenderPass& pass) {
    return beginRenderPass(pass, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);
  }

  WARN_UNUSED_RESULT int nextSubpass(VkSubpassContents contents) {
    vkCmdNextSubpass(buf, contents);
    return 0;
  }
  // nextPrimarySubpass starts the next subpass, but must be in a primary
  // command buffer.
  WARN_UNUSED_RESULT int nextPrimarySubpass() {
    return nextSubpass(VK_SUBPASS_CONTENTS_INLINE);
  }
  // nextSecondarySubpass allows a secondary command buffer to have subpasses.
  WARN_UNUSED_RESULT int nextSecondarySubpass() {
    return nextSubpass(VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);
  }

  WARN_UNUSED_RESULT int endRenderPass() {
    vkCmdEndRenderPass(buf);
    return 0;
  }

  WARN_UNUSED_RESULT int bindPipeline(VkPipelineBindPoint bindPoint,
                                      Pipeline& pipe) {
    vkCmdBindPipeline(buf, bindPoint, pipe.vk);
    return 0;
  }

  WARN_UNUSED_RESULT int bindDescriptorSets(
      VkPipelineBindPoint bindPoint, VkPipelineLayout layout, uint32_t firstSet,
      uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
      uint32_t dynamicOffsetCount = 0,
      const uint32_t* pDynamicOffsets = nullptr) {
    vkCmdBindDescriptorSets(buf, bindPoint, layout, firstSet,
                            descriptorSetCount, pDescriptorSets,
                            dynamicOffsetCount, pDynamicOffsets);
    return 0;
  }
  WARN_UNUSED_RESULT int bindGraphicsPipelineAndDescriptors(
      Pipeline& pipe, uint32_t firstSet, uint32_t descriptorSetCount,
      const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount = 0,
      const uint32_t* pDynamicOffsets = nullptr) {
    return bindPipeline(VK_PIPELINE_BIND_POINT_GRAPHICS, pipe) ||
           bindDescriptorSets(VK_PIPELINE_BIND_POINT_GRAPHICS,
                              pipe.pipelineLayout, firstSet, descriptorSetCount,
                              pDescriptorSets, dynamicOffsetCount,
                              pDynamicOffsets);
  }
  WARN_UNUSED_RESULT int bindComputePipelineAndDescriptors(
      Pipeline& pipe, uint32_t firstSet, uint32_t descriptorSetCount,
      const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount = 0,
      const uint32_t* pDynamicOffsets = nullptr) {
    return bindPipeline(VK_PIPELINE_BIND_POINT_COMPUTE, pipe) ||
           bindDescriptorSets(VK_PIPELINE_BIND_POINT_COMPUTE,
                              pipe.pipelineLayout, firstSet, descriptorSetCount,
                              pDescriptorSets, dynamicOffsetCount,
                              pDynamicOffsets);
  }

  WARN_UNUSED_RESULT int bindVertexBuffers(uint32_t firstBinding,
                                           uint32_t bindingCount,
                                           const VkBuffer* pBuffers,
                                           const VkDeviceSize* pOffsets) {
    vkCmdBindVertexBuffers(buf, firstBinding, bindingCount, pBuffers, pOffsets);
    return 0;
  }

  WARN_UNUSED_RESULT int bindIndexBuffer(VkBuffer indexBuf, VkDeviceSize offset,
                                         VkIndexType indexType) {
    vkCmdBindIndexBuffer(buf, indexBuf, offset, indexType);
    return 0;
  }

  WARN_UNUSED_RESULT int drawIndexed(uint32_t indexCount,
                                     uint32_t instanceCount,
                                     uint32_t firstIndex, int32_t vertexOffset,
                                     uint32_t firstInstance) {
    vkCmdDrawIndexed(buf, indexCount, instanceCount, firstIndex, vertexOffset,
                     firstInstance);
    return 0;
  }
  WARN_UNUSED_RESULT int bindAndDraw(const std::vector<uint16_t>& indices,
                                     VkBuffer indexBuf, VkDeviceSize offset,
                                     uint32_t instanceCount = 1,
                                     uint32_t firstIndex = 0,
                                     int32_t vertexOffset = 0,
                                     uint32_t firstInstance = 0) {
    return bindIndexBuffer(indexBuf, offset, VK_INDEX_TYPE_UINT16) ||
           drawIndexed(indices.size(), instanceCount, firstIndex, vertexOffset,
                       firstInstance);
  }
  WARN_UNUSED_RESULT int bindAndDraw(const std::vector<uint32_t>& indices,
                                     VkBuffer indexBuf,
                                     VkDeviceSize indexBufOffset,
                                     uint32_t instanceCount = 1,
                                     uint32_t firstIndex = 0,
                                     int32_t vertexOffset = 0,
                                     uint32_t firstInstance = 0) {
    return bindIndexBuffer(indexBuf, indexBufOffset, VK_INDEX_TYPE_UINT32) ||
           drawIndexed(indices.size(), instanceCount, firstIndex, vertexOffset,
                       firstInstance);
  }

  WARN_UNUSED_RESULT int drawIndexedIndirect(VkBuffer buffer,
                                             VkDeviceSize offset,
                                             uint32_t drawCount,
                                             uint32_t stride) {
    vkCmdDrawIndexedIndirect(buf, buffer, offset, drawCount, stride);
    return 0;
  }

  WARN_UNUSED_RESULT int draw(uint32_t vertexCount, uint32_t instanceCount,
                              uint32_t firstVertex, uint32_t firstInstance) {
    vkCmdDraw(buf, vertexCount, instanceCount, firstVertex, firstInstance);
    return 0;
  }

  WARN_UNUSED_RESULT int drawIndirect(VkBuffer buffer, VkDeviceSize offset,
                                      uint32_t drawCount, uint32_t stride) {
    vkCmdDrawIndirect(buf, buffer, offset, drawCount, stride);
    return 0;
  }

  WARN_UNUSED_RESULT int clearAttachments(uint32_t attachmentCount,
                                          const VkClearAttachment* pAttachments,
                                          uint32_t rectCount,
                                          const VkClearRect* pRects) {
    vkCmdClearAttachments(buf, attachmentCount, pAttachments, rectCount,
                          pRects);
    return 0;
  }

  WARN_UNUSED_RESULT int clearColorImage(
      VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor,
      uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
    vkCmdClearColorImage(buf, image, imageLayout, pColor, rangeCount, pRanges);
    return 0;
  }

  WARN_UNUSED_RESULT int clearDepthStencilImage(
      VkImage image, VkImageLayout imageLayout,
      const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount,
      const VkImageSubresourceRange* pRanges) {
    vkCmdClearDepthStencilImage(buf, image, imageLayout, pDepthStencil,
                                rangeCount, pRanges);
    return 0;
  }

  WARN_UNUSED_RESULT int dispatch(uint32_t groupCountX, uint32_t groupCountY,
                                  uint32_t groupCountZ) {
    vkCmdDispatch(buf, groupCountX, groupCountY, groupCountZ);
    return 0;
  }

  WARN_UNUSED_RESULT int dispatchIndirect(VkBuffer buffer,
                                          VkDeviceSize offset) {
    vkCmdDispatchIndirect(buf, buffer, offset);
    return 0;
  }

  struct BarrierSet {
    std::vector<VkMemoryBarrier> mem;
    std::vector<VkBufferMemoryBarrier> buf;
    std::vector<VkImageMemoryBarrier> img;
  };

  WARN_UNUSED_RESULT int barrier(BarrierSet& bset,
                                 VkPipelineStageFlags srcStageMask,
                                 VkPipelineStageFlags dstStageMask,
                                 VkDependencyFlags dependencyFlags = 0) {
    bool found = false;
    for (auto& mem : bset.mem) {
      found = true;
      if (mem.sType != VK_STRUCTURE_TYPE_MEMORY_BARRIER) {
        fprintf(stderr, "BarrierSet::mem contains invalid VkMemoryBarrier\n");
        return 1;
      }
    }
    for (auto& buf : bset.buf) {
      found = true;
      if (!buf.buffer) {
        fprintf(stderr, "BarrierSet::buf contains invalid VkBuffer\n");
        return 1;
      }
    }
    for (auto& img : bset.img) {
      found = true;
      if (!img.image) {
        fprintf(stderr, "BarrierSet::img contains invalid VkImage\n");
        return 1;
      }
    }
    if (!found) {
      fprintf(stderr, "All {mem,buf,img} were empty in BarrierSet.\n");
      return 1;
    }
    vkCmdPipelineBarrier(buf, srcStageMask, dstStageMask, dependencyFlags,
                         bset.mem.size(), bset.mem.data(), bset.buf.size(),
                         bset.buf.data(), bset.img.size(), bset.img.data());
    return 0;
  }

  //
  // The following commands require the currently bound pipeline had
  // VK_DYNAMIC_STATE_* flags enabled first.
  //

  WARN_UNUSED_RESULT int setBlendConstants(const float blendConstants[4]) {
    vkCmdSetBlendConstants(buf, blendConstants);
    return 0;
  }
  WARN_UNUSED_RESULT int setDepthBias(float constantFactor, float clamp,
                                      float slopeFactor) {
    vkCmdSetDepthBias(buf, constantFactor, clamp, slopeFactor);
    return 0;
  }
  WARN_UNUSED_RESULT int setDepthBounds(float minBound, float maxBound) {
    vkCmdSetDepthBounds(buf, minBound, maxBound);
    return 0;
  }
  WARN_UNUSED_RESULT int setLineWidth(float lineWidth) {
    vkCmdSetLineWidth(buf, lineWidth);
    return 0;
  }
  WARN_UNUSED_RESULT int setScissor(uint32_t firstScissor,
                                    uint32_t scissorCount,
                                    const VkRect2D* pScissors) {
    vkCmdSetScissor(buf, firstScissor, scissorCount, pScissors);
    return 0;
  }
  WARN_UNUSED_RESULT int setStencilCompareMask(VkStencilFaceFlags faceMask,
                                               uint32_t compareMask) {
    vkCmdSetStencilCompareMask(buf, faceMask, compareMask);
    return 0;
  }
  WARN_UNUSED_RESULT int setStencilReference(VkStencilFaceFlags faceMask,
                                             uint32_t reference) {
    vkCmdSetStencilReference(buf, faceMask, reference);
    return 0;
  }
  WARN_UNUSED_RESULT int setStencilWriteMask(VkStencilFaceFlags faceMask,
                                             uint32_t writeMask) {
    vkCmdSetStencilWriteMask(buf, faceMask, writeMask);
    return 0;
  }
  WARN_UNUSED_RESULT int setViewport(uint32_t firstViewport,
                                     uint32_t viewportCount,
                                     const VkViewport* pViewports) {
    vkCmdSetViewport(buf, firstViewport, viewportCount, pViewports);
    return 0;
  }
  // setViewport is a convenience method to update all viewports in a
  // VkRenderPass from the viewports in pass.pipelines[].info.
  WARN_UNUSED_RESULT int setViewport(RenderPass& pass) {
    std::vector<VkViewport> viewports;
    for (auto& pipe : pass.pipelines) {
      viewports.insert(viewports.end(), pipe.info.viewports.begin(),
                       pipe.info.viewports.end());
    }
    return setViewport(0, viewports.size(), viewports.data());
  }
  // setScissor is a convenience method to update all scissors in a
  // VkRenderPass from the scissors in pass.pipelines[].info.
  WARN_UNUSED_RESULT int setScissor(RenderPass& pass) {
    std::vector<VkRect2D> scissors;
    for (auto& pipe : pass.pipelines) {
      scissors.insert(scissors.end(), pipe.info.scissors.begin(),
                      pipe.info.scissors.end());
    }
    return setScissor(0, scissors.size(), scissors.data());
  }
};

}  // namespace command
